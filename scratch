
ITER {:curr-idx 0, :counted 8, :in (1 2 3 4 5 6 7 8)} will grab 4
ITER {:curr-idx 1, :counted 7, :in (1 2 3 4 6 7 8)} will grab 4
ITER {:curr-idx 2, :counted 6, :in (1 2 3 4 7 8)} will grab 5
ITER {:curr-idx 3, :counted 5, :in (1 2 3 4 7)} will grab 0
ITER {:curr-idx 4, :counted 4, :in (2 3 4 7)} will grab 2
ITER {:curr-idx 5, :counted 3, :in (2 3 7)} will grab 0
ITER {:curr-idx 6, :counted 2, :in (3 7)} will grab 1
{:curr-idx 7, :counted 1, :in (3)}

[;; a ends up with value (* 365 7) or 2555
 ;; b,c, and d are used as temporary variables
 ;; Actually d is initialised to initial value of a plus 2555
 [:cpy a d]
 [:cpy 7 c] [:cpy 365 b] [:inc d] [:dec b] [:jnz b -2] [:dec c] [:jnz c -5]
 ;; -21 brings back to here
 [:cpy d a]

 ;; b gets 2555 (if initial a was 0)
 ;; -19 brings back to here
 [:jnz 0 0] [:cpy a b] [:cpy 0 a]

 ;; b is big number that will be slowly decremented as a incremented (from 0)
 ;; when finally b is zero go to next section, having set a
 ;; and c will be either 2 or 1

 [:cpy 2 c] [:jnz b 2] [:jnz 1 6] [:dec b] [:dec c] [:jnz c -4]
 [:inc a] [:jnz 1 -7]

 ;; when c has become 0 we jump out of this line to the next
 [:cpy 2 b] [:jnz c 2] [:jnz 1 4] [:dec b] [:dec c] [:jnz 1 -4]
 [:jnz 0 0] [:out b] [:jnz a -19] [:jnz 1 -21]]